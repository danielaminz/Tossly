/*
  Tossly — Arduino firmware (thoroughly commented)
  Group 17 — Cyber Physical Systems

  ROLE
  - Receives one integer from Processing over Serial for each event:
      0 = Player 2 wins round
      1 = Player 1 wins round
      2 = Tie (not double-rock). We ignore it for scoring.
      3 = Double-rock "ready" signal (both players show Rock)
  - When value == 3, waits 3 seconds for any further input.
      If nothing else arrives, runs a countdown on both digits: 3 → 2 → 1 → clear.
      Then shows the current scores again.
  - Tracks scores for both players. When a player reaches 3:
      • Sweeps a fan servo 90° to cover the loser.
      • Runs a DC motor (music box) at full speed for 20 seconds.
      • Returns fan to neutral, resets scores to 0, redraws scoreboard.

  HARDWARE SUMMARY
  - 14 servos implement two mechanical 7-segment digits (7 segments each).
  - Top and bottom segments are mechanically linked per digit, so each digit still uses 7 servo channels.
  - We drive servos sequentially (one-by-one) to keep current draw within a strict 5 V budget.
  - A separate “fan” servo performs the winner reveal.
  - A DC motor is driven from a PWM pin (use an H-bridge or MOSFET driver — never power the motor directly from the Arduino pin).

  SERVO ANGLES (per your mechanism)
  - Segment ON  = 0°
  - Segment OFF = 90°
  - Fan angles:
      • 90° = neutral/rest
      • 0°  = cover Player 1 (left digit)
      • 180°= cover Player 2 (right digit)
*/

#include <Servo.h>

// --------------------------- Pin Mapping ---------------------------
// We need 14 servo channels for two digits (7 per digit).
// Using digital pins 2..13 for 12 servos and analog pins A0, A1 for the last two.
// Adjust these if your physical wiring differs.
const int SEG_PINS[14] = {
  2, 3, 4, 5, 6, 7, 8,      // Digit 1 (Player 1) segments a..g (top→bottom order)
  9, 10, 11, 12, 13, A0, A1 // Digit 2 (Player 2) segments a..g (top→bottom order)
};

// Fan servo to sweep the “curtain”. Put this on a stable servo-capable pin.
const int FAN_SERVO_PIN = A2;

// DC motor PWM pin through a driver (L298N, BTS7960, or logic-level MOSFET + diode).
// IMPORTANT: Never drive a motor directly from the Arduino I/O pin.
const int MOTOR_PIN = A3;   // Must be PWM-capable on your board

// --------------------------- Constants ----------------------------
// Segment actuation angles
const int SEG_ON_ANGLE  = 0;   // segment visibly “on”
const int SEG_OFF_ANGLE = 90;  // segment visibly “off”

// Fan servo angles per your convention
const int FAN_NEUTRAL   = 90;   // rest
const int FAN_COVER_P1  = 0;    // cover left digit (Player 1 loses)
const int FAN_COVER_P2  = 180;  // cover right digit (Player 2 loses)

// Timing
const unsigned long COUNTDOWN_WAIT_MS = 3000;   // wait after receiving “3” before starting countdown
const unsigned long MUSIC_TIME_MS     = 20000;  // motor run duration after match win
const unsigned long SEG_STEP_DELAY_MS = 80;     // delay between individual segment moves (power-friendly)
const unsigned long COUNT_STEP_MS     = 600;    // dwell time showing each countdown number

// --------------------------- Globals ------------------------------
Servo segServos[14];  // 14 segment servos (7 for each digit)
Servo fanServo;

int scoreP1 = 0;
int scoreP2 = 0;

// When “3” arrives we arm a timer. If no further serial data arrives by timeout,
// we run the 3-2-1 countdown.
bool          waitingForCountdown   = false;
unsigned long countdownStartMillis  = 0;

// --------------------------- 7-seg Map ----------------------------
// Each row is a digit 0..9; each col is a segment a..g in top→down order.
// 1 = ON, 0 = OFF.
// Note: You mentioned the game never shows “7”. We keep a standard map anyway.
const bool DIGIT_MAP[10][7] = {
  {1,1,1,1,1,1,0},  // 0
  {0,1,1,0,0,0,0},  // 1
  {1,1,0,1,1,0,1},  // 2
  {1,1,1,1,0,0,1},  // 3
  {0,1,1,0,0,1,1},  // 4
  {1,0,1,1,0,1,1},  // 5
  {1,0,1,1,1,1,1},  // 6
  {1,1,1,0,0,0,0},  // 7
  {1,1,1,1,1,1,1},  // 8
  {1,1,1,1,0,1,1}   // 9
};

// --------------------------- Setup --------------------------------
void setup() {
  Serial.begin(9600); // Must match Processing's BAUD

  // Attach all digit servos and move them to a safe OFF state.
  for (int i = 0; i < 14; i++) {
    segServos[i].attach(SEG_PINS[i]);
    segServos[i].write(SEG_OFF_ANGLE);
  }

  // Fan servo to neutral.
  fanServo.attach(FAN_SERVO_PIN);
  fanServo.write(FAN_NEUTRAL);

  // DC motor pin as output; ensure off at boot.
  pinMode(MOTOR_PIN, OUTPUT);
  analogWrite(MOTOR_PIN, 0);

  // Draw initial scores (0–0).
  updateScoreboard();

  Serial.println("Tossly Arduino ready");
  Serial.println("Protocol: 0=P2 win, 1=P1 win, 2=tie, 3=ready(double-rock)");
}

// --------------------------- Low-level helpers --------------------
// Writes a single segment servo with the proper ON/OFF angle and
// inserts a short delay to keep current spikes low.
void writeSegment(int servoIndex, bool on) {
  const int angle = on ? SEG_ON_ANGLE : SEG_OFF_ANGLE;
  segServos[servoIndex].write(angle);
  delay(SEG_STEP_DELAY_MS); // sequential actuation to limit power draw
}

// Sets one digit (0 = left/P1, 1 = right/P2) to a specific number (0–9),
// walking segments from top to bottom so movement reads cleanly and stays in budget.
void setDigit(int digitIndex, int number) {
  number      = constrain(number, 0, 9);
  const bool* segOn = DIGIT_MAP[number];

  // Compute starting servo index for this digit.
  // Left digit occupies 0..6, right digit occupies 7..13.
  const int base = digitIndex * 7;

  // Top-down update of segments a..g.
  for (int seg = 0; seg < 7; seg++) {
    const int servoIndex = base + seg;
    writeSegment(servoIndex, segOn[seg]);
  }
}

// Redraw both digits to match current scores.
void updateScoreboard() {
  setDigit(0, scoreP1); // left
  setDigit(1, scoreP2); // right
}

// Displays both digits as the same number for a moment. Useful for countdown.
void showBoth(int number, unsigned long dwellMs) {
  setDigit(0, number);
  setDigit(1, number);
  delay(dwellMs);
}

// Clears both digits by turning all segments OFF.
// Because top and bottom are mechanically linked, OFF is still 90° for each servo.
void clearDigits() {
  for (int i = 0; i < 14; i++) {
    segServos[i].write(SEG_OFF_ANGLE);
    delay(SEG_STEP_DELAY_MS);
  }
}

// --------------------------- Behaviours ---------------------------
// 3 → 2 → 1 then clear, then redisplay the scores.
void runCountdown() {
  showBoth(3, COUNT_STEP_MS);
  showBoth(2, COUNT_STEP_MS);
  showBoth(1, COUNT_STEP_MS);
  clearDigits();      // brief blank
  updateScoreboard(); // return to score view
}

// After a player reaches 3, run the celebration:
// - Fan covers the losing digit
// - Motor runs at full PWM for MUSIC_TIME_MS
// - Reset scores and redraw
void runWinAnimation(bool p1Winner) {
  // Decide which side to cover: the loser is the opposite of p1Winner.
  const int coverAngle = p1Winner ? FAN_COVER_P2 : FAN_COVER_P1;

  // Sweep fan to cover the losing number.
  fanServo.write(coverAngle);

  // Full-speed motor playback (through a driver).
  analogWrite(MOTOR_PIN, 255);

  // Block for the duration of the song. Since servos are idle during this,
  // blocking is acceptable for this simple sketch.
  delay(MUSIC_TIME_MS);

  // Stop motor and return fan to neutral.
  analogWrite(MOTOR_PIN, 0);
  fanServo.write(FAN_NEUTRAL);

  // Reset the match.
  scoreP1 = 0;
  scoreP2 = 0;
  updateScoreboard();
}

// --------------------------- Main Loop ----------------------------
void loop() {
  // 1) Handle incoming serial data from Processing.
  //    We expect a single integer 0/1/2/3. Using parseInt() allows
  //    simple use with Serial Monitor for testing as well.
  if (Serial.available() > 0) {
    int value = Serial.parseInt();  // returns 0 if no number found; works fine for our protocol

    if (Serial.peek() == '\n') Serial.read(); // optional: consume newline if present

    Serial.print("Received: ");
    Serial.println(value);

    // Special case: double-rock "ready" signal.
    if (value == 3) {
      waitingForCountdown = true;
      countdownStartMillis = millis();
    }
    else {
      // Any other input cancels the pending countdown window.
      waitingForCountdown = false;

      // Round outcomes
      // 0 = P2 wins (increment right digit)
      // 1 = P1 wins (increment left digit)
      // 2 = tie (not ready). We ignore for scoring.
      if (value == 1) {
        scoreP1++;
        updateScoreboard();
      } else if (value == 0) {
        scoreP2++;
        updateScoreboard();
      } else if (value == 2) {
        // Non-ready tie: do nothing to scores. Could add a blink if desired.
      }

      // Match to 3: run win animation and reset.
      if (scoreP1 >= 3) {
        runWinAnimation(true);   // Player 1 is winner; cover Player 2
      } else if (scoreP2 >= 3) {
        runWinAnimation(false);  // Player 2 is winner; cover Player 1
      }
    }
  }

  // 2) If we are waiting after a “3” and the window expired with no new input,
  //    start the countdown and then return to the score view.
  if (waitingForCountdown && (millis() - countdownStartMillis >= COUNTDOWN_WAIT_MS)) {
    waitingForCountdown = false;
    runCountdown();
  }

  // Nothing else to do; loop remains responsive to Serial input.
}

/*
  TUNING NOTES

  1) Segment direction
     If a segment looks inverted, swap SEG_ON_ANGLE / SEG_OFF_ANGLE for that mechanism
     or flip horns at assembly. Keep the top→down update order.

  2) Power budget
     Increase SEG_STEP_DELAY_MS if you see brownouts or jitter when stepping segments.
     You can also insert brief delays between setting the two digits in showBoth().

  3) Motor driver
     MOTOR_PIN must go to a proper driver input. If you use an L298N, set ENA to MOTOR_PIN
     and tie IN1/IN2 for one direction, or expand this sketch to drive both IN pins.

  4) Serial protocol
     Processing should send a single integer character (or print the integer with println).
     parseInt() is robust for both and makes manual testing easy via Serial Monitor.

  5) Countdown policy
     The 3-second window after receiving value 3 allows players to reposition without
     accidentally triggering the countdown repeatedly. If you want a stricter policy,
     you can require a second “3” to confirm before starting.

  6) Safety
     If your fan can hit mechanical stops, clamp fan angles or step the sweep in small
     increments to avoid over-torque. Same advice for segments if your linkages bind.

  7) Future power optimisation
     If you add many more servos, consider detaching idle servos (Servo.detach()) and
     only attach while moving. With 14 channels this is optional but can help on tight rails.
*/
